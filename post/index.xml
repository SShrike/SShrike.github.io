<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Shrike&#39;s Blog</title>
    <link>https://shrike.me/post/</link>
    <description>Recent content in Posts on Shrike&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-nz</language>
    <lastBuildDate>Sun, 17 Jul 2016 03:32:29 +1200</lastBuildDate>
    <atom:link href="https://shrike.me/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Some Atom Packages I Find Useful</title>
      <link>https://shrike.me/blog/2016/07/17/some-atom-packages-i-find-useful/</link>
      <pubDate>Sun, 17 Jul 2016 03:32:29 +1200</pubDate>
      
      <guid>https://shrike.me/blog/2016/07/17/some-atom-packages-i-find-useful/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve switched back to using Atom after having switched to &lt;a href=&#34;http://spacemacs.org/&#34;&gt;Spacemacs&lt;/a&gt; around six
or eight months ago. Startup time — which was one of the factors that drove me
away — has noticeably improved to the point where I don&amp;rsquo;t find it annoying and
the core text editing components have continued to mature.&lt;/p&gt;

&lt;p&gt;There are still some things I miss about Emacs/&lt;a href=&#34;http://spacemacs.org/&#34;&gt;Spacemacs&lt;/a&gt; however, such as the
mnemonic keybindings, &lt;a href=&#34;https://bitbucket.org/lyro/evil/wiki/Home&#34;&gt;evil&lt;/a&gt; (essentially a Vim emulation layer for Emacs),
&lt;a href=&#34;https://github.com/justbur/emacs-which-key&#34;&gt;which-key&lt;/a&gt; (although it is partially replaced by the command palette), and the
ability to run it in a terminal. Also, keymaps are still fairly painful to deal
with, with packages often overriding keybindings from either Atom core or other
packages. In addition to this, there also still does not seem to be any way to
define keybindings that are context-aware, a feature which would be useful for
quite few packages that are only relevant with certain filetypes —
&lt;a href=&#34;https://atom.io/packages/markdown-preview&#34;&gt;markdown-preview&lt;/a&gt;, &lt;a href=&#34;https://atom.io/packages/asciidoc-preview&#34;&gt;asciidoc-preview&lt;/a&gt;, and &lt;a href=&#34;https://atom.io/packages/emmet&#34;&gt;Emmet&lt;/a&gt; are examples of such
packages.&lt;/p&gt;

&lt;p&gt;In any case, I&amp;rsquo;ve switched back to Atom because I feel that it has sufficiently
matured and the way the editor is designed allows for a level of extensibility
that I think is essentially on par with Emacs, just without the harder to grasp
and slightly funky Emacs Lisp (although I will admit I wish it was written in
something &lt;em&gt;other&lt;/em&gt; than JavaScript/CoffeeScript).&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s get into what I&amp;rsquo;ve found to be useful and/or interesting Atom
packages that during day-to-day programming.&lt;/p&gt;

&lt;!-- Links for Intro --&gt;

&lt;h1 id=&#34;linter&#34;&gt;Linter&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://atom.io/packages/linter&#34;&gt;Linter&lt;/a&gt; is one of the first packages most people will want to install, and for
a good reason. Similar in functionality to &lt;a href=&#34;http://www.flycheck.org/&#34;&gt;Flycheck&lt;/a&gt; for Emacs, &lt;a href=&#34;https://github.com/scrooloose/syntastic&#34;&gt;Syntastic&lt;/a&gt; for
Vim, and &lt;a href=&#34;http://www.sublimelinter.com/&#34;&gt;SublimeLinter&lt;/a&gt; for Sublime Text, Linter is a package for automatically
running static code analysis, style checkers, and linters on your code either as
you type &lt;em&gt;or&lt;/em&gt; on each save. It adds a live collection of errors at the bottom of
the window as well as indicators in the gutter and popups containing the error
message when relevant code is selected.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../img/atom-linter.png&#34; alt=&#34;Linter Package&#34; /&gt;&lt;/p&gt;

&lt;!-- Links for Linter --&gt;

&lt;h1 id=&#34;minimap&#34;&gt;Minimap&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&#34;https://atom.io/packages/minimap&#34;&gt;Minimap&lt;/a&gt; package will be instantly recognisable to anyone who has used
Sublime Text. It provides — as the name suggests — a zoomed out view of the
current buffer. What makes the minimap package unique is the ability to extend
it with extra features, such as
&lt;a href=&#34;https://atom.io/packages/minimap-cursorline&#34;&gt;displaying the current line the cursor is at&lt;/a&gt;,
&lt;a href=&#34;https://atom.io/packages/minimap-selection&#34;&gt;displaying currently selected text&lt;/a&gt;,
&lt;a href=&#34;https://atom.io/packages/minimap-linter&#34;&gt;displaying linter information&lt;/a&gt;, and
&lt;a href=&#34;https://atom.io/packages/minimap-git-diff&#34;&gt;displaying Git diff information&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../img/atom-minimap.png&#34; alt=&#34;Minimap Package&#34; /&gt;&lt;/p&gt;

&lt;!-- Links for Minimap --&gt;

&lt;h1 id=&#34;editorconfig&#34;&gt;EditorConfig&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://editorconfig.org/&#34;&gt;EditorConfig&lt;/a&gt; is incredibly useful for maintaining the same coding style across
different editors and people. It&amp;rsquo;s actually not only an Atom package, it is a
file format &lt;em&gt;and&lt;/em&gt; a collection of text editor plugins; in fact, if it was
exclusive to Atom its usefulness would be hindered greatly.&lt;/p&gt;

&lt;p&gt;EditorConfig reads a &lt;code&gt;.editorconfig&lt;/code&gt; file at your project&amp;rsquo;s root, in which you
define preferences such as the preferred EOL character, charset, indent size,
etc.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-editorconfig&#34;&gt;root = true

[*]
charset = utf-8
end_of_line = lf
indent_style = space
insert_final_newline = true

[*.rs]
indent_size = 4

[*.{md,toml}]
indent_size = 2

[.travis.yml]
ident_size = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can find the Atom package for it &lt;a href=&#34;editorconfig-package&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;!-- Links for EditorConfig --&gt;

&lt;h1 id=&#34;project-manager&#34;&gt;Project Manager&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://atom.io/packages/project-manager&#34;&gt;Project Manager&lt;/a&gt; is incredibly simple and does exactly what the name implies —
it manages your projects. Usage is fairly simple: open the command palette and
search for &amp;ldquo;project manager&amp;rdquo;; from there you can save, edit, and list projects
like you would expect.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../img/atom-project-manager.png&#34; alt=&#34;Project Manager Package&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The list of projects are stored in a simple CSON file called &lt;code&gt;projects.cson&lt;/code&gt;
under &lt;code&gt;~/.atom&lt;/code&gt; which looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cson&#34;&gt;bluepill:
  title: &amp;quot;Bluepill&amp;quot;
  paths: [
    &amp;quot;/home/shrike/Documents/Projects/bluepill&amp;quot;
  ]
matrixpythonsdk:
  title: &amp;quot;Matrix Python SDK&amp;quot;
  paths: [
    &amp;quot;/home/shrike/Documents/Projects/matrix-python-sdk&amp;quot;
  ]
tutil:
  title: &amp;quot;Tutil&amp;quot;
  paths: [
    &amp;quot;/home/shrike/Documents/Projects/tutil&amp;quot;
  ]
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- Links for Project Manager --&gt;

&lt;h1 id=&#34;todo-show&#34;&gt;Todo Show&lt;/h1&gt;

&lt;p&gt;Another incredibly simple, but useful package is &lt;a href=&#34;https://atom.io/packages/todo-show&#34;&gt;Todo Show&lt;/a&gt;. Put succinctly, it
finds all &amp;ldquo;TODO&amp;rdquo;, &amp;ldquo;FIXME&amp;rdquo;, etc. comments in the currently open project and
displays them in an overview list.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../img/atom-todo-show.png&#34; alt=&#34;Todo Show Package&#34; /&gt;&lt;/p&gt;

&lt;!-- Links for Todo Show --&gt;
</description>
    </item>
    
    <item>
      <title>Welcome</title>
      <link>https://shrike.me/blog/2016/07/15/welcome/</link>
      <pubDate>Fri, 15 Jul 2016 10:16:00 +1200</pubDate>
      
      <guid>https://shrike.me/blog/2016/07/15/welcome/</guid>
      <description>&lt;p&gt;&amp;ldquo;Hello world!&amp;rdquo; I suppose that&amp;rsquo;s how you&amp;rsquo;re supposed to open the first post on a
programmer&amp;rsquo;s blog right?&lt;/p&gt;

&lt;p&gt;If that wasn&amp;rsquo;t enough, here&amp;rsquo;s hello world in some other languages (okay, I&amp;rsquo;ll
admit it, this is just me testing things now):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// C
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char const *argv[]) {
  printf(&amp;quot;Hello world!\n&amp;quot;);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// Rust
fn main() {
  println!(&amp;quot;Hello world!&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Python
print(&#39;Hello world!&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- Haskell
main :: IO ()
main = putStrLn &amp;quot;Hello world!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>